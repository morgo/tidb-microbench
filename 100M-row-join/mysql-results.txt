MySQL can index scan on a (efficient, covering index) and then assuming most rows are null, only a small subset need to join on B.
The join is by primary key.  The index (a) is in memory, and b is likely in memory.

Using MySQL 5.6.24
3 Million Rows in initial test.. will ramp up to 100M rows.

mysql> SELECT count(*) from a;
+----------+
| count(*) |
+----------+
|  3432852 |
+----------+
1 row in set (0.66 sec)

mysql> select count(*) from b;
+----------+
| count(*) |
+----------+
|  2645280 |
+----------+
1 row in set (0.66 sec)

mysql> select  count(*) from a inner join b on a.b_id = b.id;
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.88 sec)

mysql> explain select  count(*) from a inner join b on a.b_id = b.id;
+----+-------------+-------+--------+---------------+---------+---------+-------------+---------+--------------------------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref         | rows    | Extra                    |
+----+-------------+-------+--------+---------------+---------+---------+-------------+---------+--------------------------+
|  1 | SIMPLE      | a     | index  | b_id          | b_id    | 101     | NULL        | 3508325 | Using where; Using index |
|  1 | SIMPLE      | b     | eq_ref | PRIMARY       | PRIMARY | 96      | test.a.b_id |       1 | Using where; Using index |
+----+-------------+-------+--------+---------------+---------+---------+-------------+---------+--------------------------+
2 rows in set (0.00 sec)

